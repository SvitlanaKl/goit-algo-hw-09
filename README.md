# goit-algo-hw-09
Жадібні алгоритми та динамічне програмування

# Видача решти

## Жадібний алгоритм

Функція `find_coins_greedy(amount)` використовує жадібний алгоритм для визначення кількості монет кожного номіналу. Вона працює швидко, але не завжди дає оптимальний результат для всіх наборів монет.

## Динамічне програмування

Функція `find_min_coins(amount)` використовує динамічне програмування для знаходження мінімальної кількості монет. Хоча вона гарантує оптимальний результат, її ефективність може бути нижчою для великих сум через більшу обчислювальну складність.

## Порівняння

- **Часова складність:**
  - Жадібний алгоритм: \( O(n) \)
  - Динамічне програмування: \( O(n \cdot m) \)

- **Просторова складність:**
  - Жадібний алгоритм: \( O(1) \)
  - Динамічне програмування: \( O(n) \)

## Приклад використання 

- **Жадібний алгоритм**
Жадібний алгоритм вибирає монети, починаючи з найбільшого номіналу і продовжує, поки не досягне заданої суми. Це забезпечує оптимальний розподіл монет у більшості випадків, особливо коли номінали монет є кратними один одному.
Для суми 113 жадібний алгоритм повертає:
{50: 2, 10: 1, 2: 1, 1: 1}

- **Динамічне програмування**
Метод динамічного програмування знаходить оптимальний набір монет, щоб мінімізувати їх кількість для досягнення заданої суми. Це особливо корисно в ситуаціях, коли номінали монет не є кратними один одному, або коли потрібно досягти точної кількості монет.
Для суми 113 динамічне програмування повертає:
{50: 2, 10: 1, 2: 1, 1: 1}

## Висновки

Жадібний алгоритм є швидшим і простішим, але може не дати оптимального результату для всіх наборів монет. Динамічне програмування забезпечує оптимальний результат, але може бути менш ефективним для дуже великих сум через більшу обчислювальну складність і використання пам'яті.

В заданому прикладі в обох методах для суми 113 результати однакові: {50: 2, 10: 1, 2: 1, 1: 1}. Це підтверджує, що обидва алгоритми в даному випадку знаходять оптимальний розподіл монет. Жадібний алгоритм показує свою ефективність при використанні стандартних номіналів монет, а динамічне програмування підтверджує точність розрахунків для оптимального рішення.

